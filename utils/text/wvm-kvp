#!/bin/bash
### wvm-kvp: Key-Value Pair Editor ####
# Version 20120228-1 by Scott Garrett #
# Wintervenom [(at)] archlinux.us     #
#######################################
# Optional Dependencies:
# - wvm-open
#
# TODO:
# - Multi-line aliases
shopt -s extglob

version=20120928-1
tmp="/tmp/desc-editor.txt"
config="$HOME/.config/wvm-kvp"

oifs=$IFS
declare -A buffer paste aliases commands
type -p nano > /dev/null &&
    EDITOR=${EDITOR:-nano} ||
    EDITOR=${EDITOR:-vi}
type -p open > /dev/null &&
    LAUNCHER=${LAUNCHER:-open} ||
    LAUNCHER=${LAUNCHER:-wvm-open}


########################
### KVP File Parsing ###
########################
parse () {
    if [[ ! -f "$1" ]]; then
        stderr "Not found."
        return 1
    fi
    local name data trash
    buffer=()
    fmt=$(detect_fmt "$1" 2> /dev/null)
    if [[ -z $fmt ]]; then
        stderr "Unknown format."
        return 2
    fi
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        if [[ ${buffer["$name"]} ]]; then
            buffer["$name"]+=$'\n'"$data"
        else
            buffer["$name"]=$data
        fi
    done < <($"parse_kvp$fmt" "$1" 2> /dev/null)
}

detect_fmt () {
    grep -v '#' "$1" | head -3 | awk '
        /^[[:alnum:]_.-]+:/ {
            print "2"
            exit
        }
        /^[[:alnum:]_.-]+$/ {
            print "1"
            exit
        }
    '
}

parse_kvp1 () {
    awk '
        BEGIN {
            name = ""
        }
        /^[[:alnum:]_.-]/ {
            sub(/\s+$/, "", $0)
            name = $0
            next
        }
        {
            if (!name)
                next
            sub(/^\s+/, "", $0)
            sub(/\s+$/, "", $0)
            gsub(/\t/, " ", $0)
            printf "%s\t%s\n", name, $0
        }
    ' "$1"
}

parse_kvp2 () {
    awk -F':' '
        BEGIN {
            name = ""
        }
        {
            if (!name) {
                if ($0 !~ /^[[:alnum:]_.-]+:/)
                    next
                if ($2 ~ /\s*>\s*/) {
                    name = $1
                    next
                }
                printf "%s\t", $1
                sub(/^.*:\s*/, "", $0)
                sub(/\s+$/, "", $0)
                gsub(/\t/, "    ", $0)
            } else if ($2 ~ /<\s*/) {
                name = ""
                next
            } else printf "%s\t", name
            print $0
        }
    ' "$1"
}

format_kvp1 () {
    local name IFS=$'\n'
    set -f
    while read name; do
        [[ -z $name ]] &&
            continue
        echo "$name"
        printf '    %s\n' ${buffer["$name"]}
    done < <(printf '%s\n' "${!buffer[@]}" | sort)
    set +f
}

format_kvp2 () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${buffer["$name"]} != *$'\n'* ]]; then
            echo "$name: ${buffer["$name"]}"
        else
            printf '%s\n' "$name: >" "${buffer["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!buffer[@]}" | sort)
}



##################
### Key Editor ###
##################
title () {
    echo "[wvm-kvp $version - Key-Value Pair Editor]"
    echo
}

stderr () {
    echo "$1" >&2
}

save_undo () {
    undo=("$($"format_kvp$fmt")" "${undo[@]:0:49}")
    redo=()
    modified=1
}

load_aliases () {
    local name data trash
    if [[ -z "$config/aliases/$1" ]]; then
        echo "'$1' alias file not found."
        return 1
    fi
    aliases=()
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        aliases["$name"]=$data
    done < <(parse_kvp2 "$config/aliases/$1" 2> /dev/null)
    echo "Loaded aliases from '$1'."
}

format_aliases () {
    local name
    for name in "${!aliases[@]}"; do
        echo "$name: ${aliases["$name"]}"
    done
}

format_paste () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${paste["$name"]} != *$'\n'* ]]; then
            echo "$name: ${paste["$name"]}"
        else
            printf '%s\n' "$name: >" "${paste["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!paste[@]}" | sort)
}

validate () {
    [[ $1 =~ ^[[:alnum:]._-]+$ ]] &&
        return 0
    echo 'Key not found or invalid key name.'
    return 1
}

key () {
    local name
    unset found value
    [[ $2 ]] &&
        save_undo
    for name in "${!buffer[@]}"; do
        if [[ $name =~ ^$1$ ]]; then
            if [[ -z $2 ]]; then
                found=$name
                break
            else
                ((found++))
                if [[ $2 != ':u' ]]; then
                    if [[ $3 && ${buffer["$name"]} ]]; then
                        buffer["$name"]+="$3$2"
                    else
                        buffer["$name"]=$2
                    fi
                else
                    unset buffer["$name"]
                fi
            fi
        fi
    done
    if [[ $found ]]; then
        [[ -z $2 ]] &&
            value=${buffer["$name"]}
        return 0
    elif [[ $2 ]]; then
        validate "$1" ||
            return 1
        found='new'
        if [[ $2 != ':u' ]]; then
            buffer["$1"]=$2
        else
            unset buffer["$1"]
        fi
    else
        echo "No key matching '$1'."
        return 1
    fi
}

paste_key () {
    local name
    unset found value
    for name in "${!paste[@]}"; do
        if [[ $name =~ ^$1$ ]]; then
            if [[ -z $2 ]]; then
                found=$name
                break
            else
                ((found++))
                if [[ $2 != ':u' ]]; then
                    if [[ $3 && ${paste["$name"]} ]]; then
                        paste["$name"]+="$3$2"
                    else
                        paste["$name"]=$2
                    fi
                else
                    unset paste["$name"]
                fi
            fi
        fi
    done
    if [[ $found ]]; then
        [[ -z $2 ]] &&
            value=${paste["$name"]}
        return 0
    elif [[ $2 ]]; then
        validate "$1" ||
            return 1
        found='new'
        if [[ $2 != ':u' ]]; then
            paste["$1"]=$2
        else
            unset paste["$1"]
        fi
    else
        echo "No key matching '$1'."
        return 1
    fi
}

prompt () {
    buffer_lines=$($"format_kvp$fmt" | wc -l)
    paste_lines=$($"format_paste" | wc -l)
    ((buffer_offset > buffer_lines)) &&
        ((buffer_offset = buffer_lines))
    ((buffer_offset < 1)) &&
        buffer_offset=1
    ((paste_offset > paste_lines)) &&
        ((paste_offset = paste_lines))
    ((paste_offset < 1)) &&
        paste_offset=1
    printf '\n(%2d,%2d) [KVP%s: %s]\n' $buffer_offset $((buffer_offset+10)) \
        "$fmt" "${file##*/}"
    $"format_kvp$fmt" | sed -n "$buffer_offset,$((buffer_offset + 10))p"
    printf '\n\n(%2d,%2d) [Paste Buffer]\n' $paste_offset $((paste_offset+10))
    format_paste | sed -n "$paste_offset,$((paste_offset + 10))p"
    printf '\n\n'
    read -e -p"$1> " cmd target data
    clear
    title
}

load_commands () {
    local command params param names name count
    echo 'Initializing command functions...'
    commands=()
    for command in $(compgen -A function cmd_); do
        unset params names count
        $command -i
        for name in ${command:4} ${names[@]}; do
            commands[$name]=$command
        done
        for param in "${params[@]}"; do
            [[ ${param:0:1} != '?' ]] &&
                ((++count))
        done
        parameters[$command]=$count
    done
}



#######################
### Editor Commands ###
#######################
_cmd_template () {
    case "$1" in
        '-i')
            params=()
            names=()
            ;;
        '-h')
            cat <<'EOF'
EOF
            ;;
        *)
            ;;
    esac
}

_cmd_usage () {
    local command params param names name count
    unset params names count
    if [[ -z ${commands["$1"]} ]]; then
        echo "Unknown command: $1"
        return 1
    fi
    command=${commands["$1"]}
    $command -i
    echo "${command:4}$(printf ' %s' "${params[@]}")"
    echo "    Aliases:$(printf ' %s' "${names[@]}")"
    parameters[$command]=$count
    $command -h | tr '\n' ' ' | fold -s -w $((${COLUMNS:-40} - 4)) |
        sed 's/^/    /'
    echo
    echo
}

cmd_set () {
    case "$1" in
        '-i')
            params=('key' '?text')
            names=('=' 's')
            ;;
        '-h')
            cat <<'EOF'
Sets the value of keys matching <key> to <text>. If <text> is left blank, then
$EDITOR will be launched for you to edit the key's value. If <text> is set to
a period, the name of the file being edited (without the extension) will be
substituted.
EOF
            ;;
        *)
            local text
            if [[ $2 ]]; then
                text=$2
            else
                if [[ $3 ]]; then
                    echo > "$tmp"
                else
                    key "$1" > "$tmp" ||
                        return 1
                fi
                $EDITOR "$tmp"
                text=$(sed -e :a -e '/./,$!d;/^\n*$/N;/\n$/ba' "$tmp")
                if [[ $? != 0 ]]; then
                    stderr 'Empty value. No changes made.'
                    return 1
                fi
                rm -f "$tmp"
            fi
            if [[ -z $text ]]; then
                stdout 'Empty value.  No changes made.'
                return 1
            elif [[ $text == '.' ]]; then
                text=${file##*/}
                text=${text%.*}
            fi
            key "$1" "$text" "$3" ||
                return 1
            echo "Updated value of $found key(s) matching '$1'."
            ;;
    esac
}

cmd_add () {
    case "$1" in
        '-i')
            params=('key' '?text')
            names=('+' 'a')
            ;;
        '-h')
            cat <<'EOF'
Same as the `set` command, but appends <text> to the value of <key>, prefixed
with a space, if the key is not empty.
EOF
            ;;
        *)
            cmd_set "$1" "$2" ' '
            ;;
    esac
}

cmd_addln () {
    case "$1" in
        '-i')
            params=('key' '?value')
            names=(';' 'l')
            ;;
        '-h')
            cat <<'EOF'
Same as the `set` command, but appends <text> to the value of <key>, prefixed
with a newline, if the key is not empty.
EOF
            ;;
        *)
            cmd_set "$1" "$2" $'\n'
            ;;
    esac
}

cmd_unset () {
    case "$1" in
        '-i')
            params=('key' '?buffer')
            names=('-' 'rm')
            ;;
        '-h')
            cat <<'EOF'
Deletes keys matching <key>. If <buffer> is set to 'paste'/'p', the matching
keys will be deleted from the paste buffer instead of the main one. If it is
set to 'all'/'a', will delete matching keys from both buffers.
EOF
            ;;
        *)
            if [[ $2 == @(p|paste) ]]; then
                paste_key "$1" :u &&
                    echo "Deleted $found paste key(s) matching '$1'."
            fi
            if [[ -z $2 || $2 == @(a|all) ]]; then
                key "$1" :u &&
                    echo "Deleted $found key(s) matching '$1'."
            fi
            ;;
    esac
}

cmd_clear () {
    case "$1" in
        '-i')
            params=('[a]ll|[b]uffer|[p]aste')
            names=('x')
            ;;
        '-h')
            cat <<'EOF'
Clears all keys from either the main buffer, pastes, or both.
EOF
            ;;
        *)
            case "$1" in
                a|all)
                    paste=()
                    echo 'Cleared pastes'
                    ;&
                b|buffer)
                    save_undo
                    buffer=()
                    echo 'Cleared buffer.'
                    ;;
                p|paste)
                    paste=()
                    echo 'Cleared pastes'
                    ;;
                *)
                    echo 'Unknown buffer.'
                    return 1
                    ;;
            esac
            ;;
    esac
}

cmd_copy () {
    case "$1" in
        '-i')
            params=('?key' '?to')
            names=('c')
            ;;
        '-h')
            cat <<'EOF'
Copies key matching <key> to the paste buffer, optionally to different key(s)
(<to>). If <key> is empty, will copy all keys.
EOF
            ;;
        *)
            local target name
            if [[ $1 ]]; then
                target=${2:-$1}
                key "$1" ||
                    return 1
                name=$found
                paste_key "$target" "$value" ||
                    return 1
                echo "Copied key '$name' as $found paste(s) matching '$target'."
            else
                for name in "${!buffer[@]}"; do
                    paste["$name"]=${buffer["$name"]}
                done
                echo 'Copied all keys.'
            fi
            ;;
    esac
}

cmd_paste () {
    case "$1" in
        '-i')
            params=('?key' '?to')
            names=('p')
            ;;
        '-h')
            cat <<'EOF'
Pastes key matching <key> from the paste buffer, optionally to different key(s)
(<to>). If <key> is empty, will paste all keys.
EOF
            ;;
        *)
            local target name
            if [[ $1 ]]; then
                target=${2:-$1}
                paste_key "$1" ||
                    return 1
                name=$found
                key "$target" "$value" ||
                    return 1
                echo "Pasted '$name' to $found key(s) matching '$target'."
            else
                for name in "${!paste[@]}"; do
                    buffer["$name"]=${paste["$name"]}
                done
                echo 'Pasted all keys.'
            fi
            ;;
    esac
}

cmd_undo () {
    case "$1" in
        '-i')
            params=()
            names=('z')
            ;;
        '-h')
            cat <<'EOF'
Restores main buffer to state before the last edit. Up to 50 changes are saved.
EOF
            ;;
        *)
            if [[ $undo ]]; then
                redo=("$($"format_kvp$fmt")" "${redo[@]}")
                printf '%s\n' "$undo" > "$tmp"
                undo=("${undo[@]:1}")
                parse "$tmp"
                rm -f "$tmp" 2> /dev/null
                modified=1
                echo 'Reverted last change.'
            else
                echo 'Already at oldest change.'
            fi
            ;;
    esac
}

cmd_redo () {
    case "$1" in
        '-i')
            params=()
            names=('y')
            ;;
        '-h')
            cat <<'EOF'
Restores main buffer to state before the last undo (if it hasn't been changed
since then).
EOF
            ;;
        *)
            if [[ $redo ]]; then
                undo=("$($"format_kvp$fmt")" "${undo[@]}")
                printf '%s\n' "$redo" > "$tmp"
                redo=("${redo[@]:1}")
                parse "$tmp"
                rm -f "$tmp" 2> /dev/null
                modified=1
                echo 'Restored last change.'
            else
                echo 'Already at latest change.'
            fi
            ;;
    esac
}

cmd_rename () {
    case "$1" in
        '-i')
            params=('key' 'name')
            names=('r' 'mv')
            ;;
        '-h')
            cat <<'EOF'
Renames key matching <key> to <name>.
EOF
            ;;
        *)
            local name
            validate "$2" ||
                return 1
            key "$1 " ||
                return 1
            name=$found
            unset buffer["$name"]
            key "$2" "$value" ||
                return 1
            echo "Renamed key '$name' to '$2'."
            ;;
    esac
}

cmd_lowercase () {
    case "$1" in
        '-i')
            params=('key')
            names=('l' 'lower')
            ;;
        '-h')
            cat <<'EOF'
Lowercases the value of key matching <key>.
EOF
            ;;
        *)
            local name
            key "$1" ||
                return 1
            name=$found
            key "$name" "${value,,}" ||
                return 1
            echo "Lowercased value of key '$name'."
            ;;
    esac
}

cmd_uppercase () {
    case "$1" in
        '-i')
            params=('key')
            names=('u' 'upper')
            ;;
        '-h')
            cat <<'EOF'
Uppercases the value of key matching <key>.
EOF
            ;;
        *)
            local name
            key "$1" ||
                return 1
            name=$found
            key "$name" "${value^^}" ||
                return 1
            echo "Uppercased value of key '$name'."
            ;;
    esac
}

cmd_sed () {
    case "$1" in
        '-i')
            params=('key' 'script')
            names=('%')
            ;;
        '-h')
            cat <<'EOF'
Sets the value of key matching <key> to the result of a Sed operation using
<script>. Sed will be executed with extended regular expressions enabled.
EOF
            ;;
        *)
            local name
            key "$1" ||
                return 1
            name=$found
            value=$(printf '%s\n' "$value" | sed -r "$2")
            if [[ $? == 0 ]]; then
                key "$name" "$value" ||
                    return 1
                echo "Updated value of key '$name'."
            fi
            ;;
    esac
}

cmd_find () {
    case "$1" in
        '-i')
            params=('key|*' '?string')
            names=('/' 'search')
            ;;
        '-h')
            cat <<'EOF'
Searches for a key matching <key> or, if <string> is specified, for <string>
in <key>. If <key> is '*', will search all keys.
EOF
            ;;
        *)

            ;;
    esac
}

cmd_alias () {
    case "$1" in
        '-i')
            params=('name' 'command|ls|[l]oad|[s]ave')
            names=()
            ;;
        '-h')
            cat <<'EOF'
Creates, modifies, saves, and loads single-word aliases to perform commands.
EOF
            ;;
        *)
            local name target=${2:-default}
            case "$1" in
                s|w|save|write)
                    format_aliases > "$config/aliases/$target"
                    echo "'$target' aliases file updated."
                    ;;
                l|load)
                    load_aliases "$target"
                    ;;
                ls|list)
                    for name in "${!aliases[@]}"; do
                        printf '%s: %s\n' "$name" "${aliases["$name"]}"
                    done
                    ;;
                *)
                    if [[ $2 ]]; then
                        aliases["$1"]=$2
                        echo "Alias '$1' created."
                    else
                        unset aliases["$1"]
                        echo "Alias '$1' deleted."
                    fi
                    ;;
            esac
            ;;
    esac
}

cmd_format () {
    case "$1" in
        '-i')
            params=()
            names=('f' 'fmt')
            ;;
        '-h')
            cat <<'EOF'
Toggles the buffer format between KVP1 and KVP2.
EOF
            ;;
        *)
            fmt=$((!--fmt + 1))
            ;;
    esac
}

cmd_open () {
    case "$1" in
        '-i')
            params=()
            names=('o' 'launch')
            ;;
        '-h')
            cat <<'EOF'
Opens the related file that is detected by the editor with the executable in
$LAUNCHER. If more than one related file is found, will prompt you to choose
which one to open.
EOF
            ;;
        *)
            if [[ -z $LAUNCHER ]]; then
                echo 'No $LAUNCHER is set.'
            else
                local IFS=$'\n'
                shopt -s nullglob
                local files=("${file%.*}".!("${file##*.}"))
                shopt -u nullglob
                IFS=$oifs
                local count=${#files[@]}
                if [[ $count == 0 ]]; then
                    echo 'No related files found.'
                elif [[ $count == 1 ]]; then
                    echo "Opened $files with $LAUNCHER."
                    $LAUNCHER "$files"
                else
                    count=0
                    for f in "${files[@]}"; do
                        echo "$((count++)): $f"
                    done | less -P'[Arrows] Scroll    [Q] Continue'
                    prompt 'Open which file (none to cancel)? '
                    if [[ $f =~ '^[0-9]+$' && ${files["$f"]} ]]; then
                        echo "Opened ${files[$f]} with $LAUNCHER."
                        $LAUNCHER "${files[$f]}"
                    else
                        echo 'Invalid number selected.'
                    fi
                fi
            fi
            ;;
    esac
}

cmd_write () {
    case "$1" in
        '-i')
            params=('?filepath')
            names=('w' 'save')
            ;;
        '-h')
            cat <<'EOF'
Writes main buffer to file, optionally to a different <filepath> than what was
opened. '.' used as a filepath will write to the original file (default).
EOF
            ;;
        *)
            local name
            [[ -z $1 || $1 == '.' ]] &&
                name=$file
            $"format_kvp$fmt" > "$name"
            echo "Wrote file: $name"
            unset modified
            ;;
    esac
}

cmd_revert () {
    case "$1" in
        '-i')
            params=()
            names=('e')
            ;;
        '-h')
            cat <<'EOF'
Revert main buffer to the last-saved state.
EOF
            ;;
        *)
            save_undo
            parse "$file" ||
                return 1
            echo 'Reverted all changes.'
            unset modified
            ;;
    esac
}

cmd_go () {
    case "$1" in
        '-i')
            params=('?index')
            names=('g')
            ;;
        '-h')
            cat <<'EOF'
Opens the <index>-th file in the list of files to edit. If <index> is left
blank, will list the files and indexes.
EOF
            ;;
        *)
            if [[ $1 ]]; then
                local next
                if [[ ${1:0:1} == @('+'|'-') ]]; then
                    next=$((index $1))
                elif [[ $1 =~ ^[[:digit:]]+$ ]]; then
                    next=$1
                else
                    stderr 'Invalid index.'
                    return 1
                fi
                if [[ $next -lt 0 || $next -gt ${#files[@]} ]]; then
                    stderr 'No file to edit past the specified point.'
                    return 1
                else
                    index=$next
                fi
            else
                local f count=0
                for f in "${files[@]}"; do
                    printf '%3d) %s\n' $((count++)) "$f"
                done | less -P'[Arrows] Scroll    [Q] Go Back'
            fi
            ;;
    esac
}

cmd_prev() {
    case "$1" in
        '-i')
            params=('?count')
            names=('<' 'v')
            ;;
        '-h')
            cat <<'EOF'
Opens the previous file in the list of files to edit. If <count> is specified,
goes back this many files. Sam as `go -N`.
EOF
            ;;
        *)
            cmd_go -${1:-1}
            ;;
    esac
}

cmd_next () {
    case "$1" in
        '-i')
            params=('?count')
            names=('>' 'n')
            ;;
        '-h')
            cat <<'EOF'
Opens the next file in the list of files to edit. If <count> is specified,
goes forward this many files. Same as `go +N`.
EOF
            ;;
        *)
            cmd_go +${1:-1}
            ;;
    esac
}

cmd_up () {
    case "$1" in
        '-i')
            params=('?count' '?buffer')
            names=('[')
            ;;
        '-h')
            cat <<'EOF'
Scrolls main buffer up one half-page, by default. If <count> is specifed, then
scrolls up this many lines. If 'paste' is specified for <buffer>, will scroll
the paste buffer, instead.
EOF
            ;;
        *)
            if [[ $2 != 'paste' ]]; then
                ((buffer_offset-=${1:-5}))
            else
                ((paste_offset-=${1:-5}))
            fi
            ;;
    esac
}

cmd_dn () {
    case "$1" in
        '-i')
            params=('?count' '?buffer')
            names=(']')
            ;;
        '-h')
            cat <<'EOF'
Scrolls main buffer down one half-page, by default. If <count> is specifed, then
scrolls down this many lines. If 'paste' is specified for <buffer>, will scroll
the paste buffer, instead.
EOF
            ;;
        *)
            if [[ $2 != 'paste' ]]; then
                ((buffer_offset+=${1:-5}))
            else
                ((paste_offset+=${1:-5}))
            fi
            ;;
    esac
}

cmd_quit () {
    case "$1" in
        '-i')
            params=()
            names=('q')
            ;;
        '-h')
            cat <<'EOF'
Exits the editor.
EOF
            ;;
        *)
            if [[ $modified ]]; then
                prompt 'Save changes (Y/n)? '
                if [[ -z $cmd || ${cmd,,} == 'y' ]]; then
                    $"format_kvp$fmt" > "$file"
                    echo "Wrote KVP$fmt: $file"
                fi
            fi
            unset index
            ;;
    esac
}

cmd_help () {
    case "$1" in
        '-i')
            params=('?command')
            names=('h' 'help' 'cmds' 'commands')
            ;;
        '-h')
            cat <<'EOF'
You are currently here. Press [q] to return to the editor.
EOF
            ;;
        *)
            local command
            for command in $(compgen -A function cmd_ | sort); do
                _cmd_usage ${command:4}
            done | less -P'[Arrows] Scroll    [Q] Go Back'
            ;;
    esac
}



############
### Main ###
############

if [[ -z $1 || $1 == @('-h'|'--help') ]]; then
    echo "wvm-kvp - Key-Value Pair Editor"
    echo "Version $version by Scott Garrett"
    echo "Wintervenom [(at)] gmail.com"
    echo
    echo "Usage: ${0##*/} <file ...>"
    exit 2
fi

files=("$@")
index=0

mkdir -p "$config/"{aliases,plugins}
clear
title
echo 'Loading plugins...'
while read file; do
    . "$file"
done < <(find "$config/plugins" -type f)
load_commands
while [[ $index ]]; do
    unset modified
    undo=()
    redo=()
    buffer_offset=1
    paste_offset=1
    cindex=$index
    file=${files[index]}
    if [[ ${file##*.} != @(txt|text|desc|meta|kvp|rc|conf|cfg) ]]; then
        echo "Related: $file"
        file="${file%.*}.txt"
    fi
    echo "Parsing: $file"
    if ! parse "$file"; then
        echo 'Using blank KVP2.'
        fmt=2
    fi
    while [[ $index == $cindex ]]; do
        prompt
        unset append go
        cmd=${cmd,,}
        target=${target,,}
        [[ $cmd && ${aliases["$cmd"]} ]] &&
            read cmd target data <<< "${aliases["$cmd"]}"
        [[ -z $cmd ]] &&
            continue
        command=${commands["$cmd"]}
        if [[ $command ]]; then
            unset names params
            $command -i
            if [[ ${params[1]} && ${params[1]:0:1} != '?' ]]; then
                [[ $data ]]
            elif [[ ${params[0]} && ${params[0]:0:1} != '?' ]]; then
                [[ $target ]]
            fi
            if [[ $? == 0 ]]; then
                $command "$target" "$data"
            else
                _cmd_usage "$cmd"
            fi
        else
            echo 'Unknown command.'
        fi
    done
done
echo 'Exiting.'
