#!/bin/bash
### wvm-kvp: Key-Value Pair Editor ####
# Version 20120220-3 by Scott Garrett #
# Wintervenom [(at)] archlinux.us     #
#######################################
# Optional Dependencies:
# - wvm-open
shopt -s extglob

version=20120920-3
tmp="/tmp/desc-editor.txt"
config="$HOME/.config/wvm-kvp"

declare -A key buffer aliases
type -p nano > /dev/null &&
    EDITOR=${EDITOR:-nano} ||
    EDITOR=${EDITOR:-vi}
type -p open > /dev/null &&
    LAUNCHER=${LAUNCHER:-open} ||
    LAUNCHER=${LAUNCHER:-wvm-open}


########################
### KVP File Parsing ###
########################
parse () {
    local name data trash
    key=()
    if [[ ! -f "$1" ]]; then
        echo "Not found."
        return 1
    fi
    fmt=$(detect_fmt "$1" 2> /dev/null)
    if [[ -z $fmt ]]; then
        echo "Unknown format."
        return 2
    fi
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        if [[ ${key["$name"]} ]]; then
            key["$name"]+=$'\n'"$data"
        else
            key["$name"]=$data
        fi
    done < <($"parse_kvp$fmt" "$1" 2> /dev/null)
}

detect_fmt () {
    grep -v '#' "$1" | head -3 | awk '
        /^[[:alnum:]_.-]+:/ {
            print "2"
            exit
        }
        /^[[:alnum:]_.-]+$/ {
            print "1"
            exit
        }
    '
}

parse_kvp1 () {
    awk '
        BEGIN {
            name = ""
        }
        /^[[:alnum:]_.-]/ {
            sub(/\s+$/, "", $0)
            name = $0
            next
        }
        {
            if (!name)
                next
            sub(/^\s+/, "", $0)
            sub(/\s+$/, "", $0)
            gsub(/\t/, " ", $0)
            printf "%s\t%s\n", name, $0
        }
    ' "$1"
}

parse_kvp2 () {
    awk -F':' '
        BEGIN {
            name = ""
        }
        {
            if (!name) {
                if ($0 !~ /^[[:alnum:]_.-]+:/)
                    next
                if ($2 ~ /\s*>\s*/) {
                    name = $1
                    next
                }
                printf "%s\t", $1
                sub(/^.*:\s*/, "", $0)
                sub(/\s+$/, "", $0)
                gsub(/\t/, "    ", $0)
            } else if ($2 ~ /<\s*/) {
                name = ""
                next
            } else printf "%s\t", name
            print $0
        }
    ' "$1"
}

format_kvp1 () {
    local name IFS=$'\n'
    set -f
    while read name; do
        [[ -z $name ]] &&
            continue
        echo "$name"
        printf '    %s\n' ${key["$name"]}
    done < <(printf '%s\n' "${!key[@]}" | sort)
    set +f
}

format_kvp2 () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${key["$name"]} != *$'\n'* ]]; then
            echo "$name: ${key["$name"]}"
        else
            printf '%s\n' "$name: >" "${key["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!key[@]}" | sort)
}



##################
### Key Editor ###
##################
title () {
    echo '------------------------------------------'
    echo "wvm-kvp $version - Key-Value Pair Editor"
    echo '------------------------------------------'
}

syntax () {
    IFS=' ' echo "Syntax: $1 $(printf "<%s> " "${@:2}")"
}

cmd_usage () {
    cat <<'EOF'
    wvm-kvp - Key-Value Pair Editor Command Usage

help
    Aliases: h, cmds, commands
    You are currently here.
    Press [q] to return to the editor.

add <key> <value>
    Aliases: a, +
    Appends value of a key, prefixed with a space
    (if it isn't empty).  Will prompt for a value
    if <value> is left blank.  If the <value> is
    '.', the base name of the current file will be
    used.

addln <key> [value]
    Aliases: l, ;
    Appends value of a key as a new line (if it
    isn't empty).  If <value> is left blank, the
    executable defined in $EDITOR will be used to
    edit a value for the key, and the saved file
    will be appended (with any blank lines at its
    beginning or end removed) if it is not empty.
    If <value> is '.', the base name of the cur-
    rent file will be used.

set <key> [value]
    Aliases: s, =
    Sets the value of a key, replacing its value.
    Same behavior as `addln` if <value> is left
    blank, except contents of saved file replace
    the current value if it is not empty.  If the
    <value> is '.', the base name of the current
    file will be used.

unset <key> (paste,p|both,b)
    Aliases: u, -, rm
    Deletes a key (and its value).  If 'paste' or
    'p' is added, deletes the key from the paste
    buffer.  If 'both' or 'b' is added, deletes
    the key from both buffers.

copy [key] [as]
    Aliases: c
    Copies a key to the paste buffer, optionally
    with a different key name (<as>).  If <key>
    is empty, will copy all keys (<as> will be
    ignored in this case).

paste [key] [to]
    Aliases: [p]
    Pastes a key from the paste buffer, optionally
    to a different key name than what was copied
    (<to>).  If <key> is empty, will paste all keys
    (<to> will be ignored in this case).

undo
    Aliases: z
    Restores KVPs to state before the last edit
    operation.  Up to 50 changes are saved.

redo
    Aliases: y
    Restores KVPs to state before the last undo

rename <key> <to>
    Aliases: r
    Renames a key to something else (<to>).

lowercase <key>
    Aliases: l, lower
    Lowercases the value of a key.

uppercase <key>
    Aliases: u, lower
    Capitalizes the value of a key.

sed <key> <script>
    Aliases: %
    Sets the value of a key to the result of a
    Sed operation using <script>.  Sed will be
    executed with extended regular expressions
    enabled.

format
    Aliases: f, fmt
    Toggles the KVP format between KVP1 and KVP2.

open
    Aliases: o
    Opens related file that is detected by the
    editor with the executable in $LAUNCHER.
    If more than one related file is detected,
    will prompt you to choose which to open.

write [filepath|.] (v1,1|v2,2)
    Aliases: w, save
    Writes KVP output to file, optionally to a
    different <filepath> than what was opened.
    '.' used as a file path will write to the
    original file (default behavior).  Output
    is written in whichever KVP version it was
    opened in unless a KVP version is specified
    after the file path ('v1'/'1' or 'v2'/'2').

revert
    Aliases: e
    Revert to the last-saved state.

next
    Aliases: n, >
    Move to the next file to edit (by index).

prev
    Aliases: v, <
    Move to the last-edited file (by index).

quit
    Aliases: q, exit
    Exits the editor.
EOF
}

save_undo () {
    undo=("$($"format_kvp$fmt")" "${undo[@]:0:49}")
    redo=()
    modified=1
}

load_aliases () {
    local name data trash
    if [[ -z "$config/aliases/$1" ]]; then
        echo "'$1' alias file not found."
        return 1
    fi
    aliases=()
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        aliases["$name"]=$data
    done < <(parse_kvp2 "$config/aliases/$1" 2> /dev/null)
    echo "Loaded aliases from '$1'."
}

format_aliases () {
    local name
    for name in "${!aliases[@]}"; do
        echo "$name: ${aliases["$name"]}"
    done
}

format_buffer () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${buffer["$name"]} != *$'\n'* ]]; then
            echo "$name: ${buffer["$name"]}"
        else
            printf '%s\n' "$name: >" "${buffer["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!buffer[@]}" | sort)
}

deblank () {
    sed '/./,$!d' "$1" | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'
}

validate () {
    [[ $1 =~ ^[[:alnum:]._-]+$ ]] &&
        return 0
    echo 'Key not found or invalid key name.'
    return 1
}

key () {
    local quiet name found
    if [[ $1 == '-q' ]]; then
        quiet=1
        shift
    fi
    for name in "${!key[@]}"; do
        if [[ $name == $1 ]]; then
            if [[ -z $2 ]]; then
                found=$name
                break
            else
                ((found++))
                if [[ $3 && ${key["$name"]} ]]; then
                    key["$name"]+="$3$2"
                else
                    key["$name"]=$2
                fi
            fi
        fi
    done
    if [[ $found ]]; then
        [[ -z $quiet ]] &&
            echo "$found"
        return 0
    elif [[ $2 ]]; then
        validate "$1" ||
            return 1
        key["$1"]=$2
    else
        return 1
    fi
}

paginate () {
    # TODO
    true
}

key_editor () {
    local file=$1 cmd name data modified append undo=() redo=()
    if [[ ${file##*.} != @(txt|text|desc|meta|kvp|rc|conf|cfg) ]]; then
        echo "Related: $file"
        file="${file%.*}.txt"
    fi
    echo "Parsing: $file"
    if ! parse "$file"; then
        echo 'Using blank KVP2.'
        fmt=2
    fi
    while :; do
        printf '\n[KVP%s: %s]\n' "$fmt" "${file##*/}"
        $"format_kvp$fmt"
        printf '\n\n[Paste Buffer]\n'
        format_buffer
        printf '\n\n'
        read -e -p'> ' cmd name data
        clear
        title
        unset append go
        cmd=${cmd,,}
        name=${name,,}
        [[ $cmd && ${aliases["$cmd"]} ]] &&
            read cmd name data <<< "${aliases["$cmd"]}"
        case "$cmd" in
            a|+|add)
                if [[ -z $name ]]; then
                    syntax $cmd key value
                else
                    [[ -z $data ]] &&
                        read -e -p"$name> " data
                    if [[ -z $data ]]; then
                        continue
                    elif [[ $data == '.' ]]; then
                        data=${file##*/}
                        data=${data%.*}
                    fi
                    save_undo
                    key -q "$name" "$data" ' ' &&
                        echo "Updated value of key '$name'."
                fi
                ;;
            l|';'|addln)
                append=1
                ;&
            s|=|set)
                if [[ -z $name ]]; then
                    syntax $cmd key '[value]'
                else
                    if [[ -z $data ]]; then
                        [[ -z $append ]] &&
                            key "$name" > "$tmp" ||
                            echo > "$tmp"
                        $EDITOR "$tmp"
                        data=$(deblank "$tmp") ||
                            continue
                        rm -f "$tmp"
                    fi
                    if [[ -z $data ]]; then
                        continue
                    elif [[ $data == '.' ]]; then
                        data=${file##*/}
                        data=${data%.*}
                    fi
                    save_undo
                    if [[ -z $append ]]; then
                        key["$name"]=$data # Here.
                    elif [[ ${key["$name"]} ]]; then
                        key["$name"]+=$'\n'"$data"
                    else
                        key["$name"]=$data
                    fi
                    echo "Updated value of key '$name'."
                fi
                ;;
            u|-|rm|unset)
                if [[ -z $name ]]; then
                    syntax $cmd key '(paste,p|both,b)'
                else
                    if [[ $data == @(paste|p) ]]; then
                        unset buffer["$name"]
                        echo "Deleted paste buffer key '$name'."
                    fi
                    if [[ -z $data || $data == @(both|b) ]]; then
                        save_undo
                        unset key["$name"]
                        echo "Deleted key '$name'."
                    fi
                fi
                ;;
            x|clear)
                if [[ -z $name ]]; then
                    syntax $cmd '(key,k|p,paste|both,b)'
                else
                    case "$name" in
                        b|both)
                            buffer=()
                            echo 'Cleared paste buffer.'
                            ;&
                        k|keys)
                            save_undo
                            key=()
                            echo 'Deleted all keys.'
                            ;;
                        p|paste)
                            buffer=()
                            echo 'Cleared paste buffer.'
                            ;;
                    esac
                fi
                ;;
            c|copy)
                if [[ $name ]]; then
                    [[ -z $data ]] &&
                        data=$name
                    buffer["$data"]=${key["$name"]}
                    echo "Copied key '$name' as '$data'."
                else
                    for name in "${!key[@]}"; do
                        buffer["$name"]=${key["$name"]}
                    done
                    echo 'Copied all keys.'
                fi
                ;;
            p|paste)
                save_undo
                if [[ $name ]]; then
                    [[ -z $data ]] &&
                        data=$name
                    key["$data"]=${buffer["$name"]}
                    echo "Pasted key '$name' to '$data'."
                else
                    for name in "${!buffer[@]}"; do
                        key["$name"]=${buffer["$name"]}
                    done
                    echo 'Pasted all keys.'
                fi
                ;;
            z|undo)
                if [[ $undo ]]; then
                    redo=("$($"format_kvp$fmt")" "${redo[@]}")
                    printf '%s\n' "$undo" > "$tmp"
                    undo=("${undo[@]:1}")
                    parse "$tmp"
                    rm -f "$tmp" 2> /dev/null
                    modified=1
                    echo 'Reverted last change.'
                else
                    echo 'Already at oldest change.'
                fi
                ;;
            y|redo)
                if [[ $redo ]]; then
                    undo=("$($"format_kvp$fmt")" "${undo[@]}")
                    printf '%s\n' "$redo" > "$tmp"
                    redo=("${redo[@]:1}")
                    parse "$tmp"
                    rm -f "$tmp" 2> /dev/null
                    modified=1
                    echo 'Restored last change.'
                else
                    echo 'Already at latest change.'
                fi
                ;;
            r|rename)
                if [[ -z $name || -z $data ]]; then
                    syntax $cmd key to
                else
                    save_undo
                    modified=${key["$name"]}
                    unset key["$name"]
                    key["$data"]=$modified
                    echo "Renamed key '$name' to '$data'."
                fi
                ;;
            l|lower|lowercase)
                if [[ -z $name ]]; then
                    syntax $cmd key
                else
                    save_undo
                    key["$name"]=${key["$name"],,}
                    echo "Lowercased value of key '$name'."
                fi
                ;;
            u|upper|uppercase)
                if [[ -z $name ]]; then
                    syntax $cmd key
                else
                    save_undo
                    key["$name"]=${key["$name"]^^}
                    echo "Uppercased value of key '$name'."
                fi
                ;;
            '%'|sed)
                if [[ -z $name || -z $data ]]; then
                    syntax $cmd key script
                else
                    data=$(printf '%s\n' "${key["$name"]}" | sed -r "$data")
                    retcode=$?
                    if ((retcode == 0)); then
                        save_undo
                        key["$name"]=$data
                        echo "Updated value of key '$name'."
                    fi
                fi
                ;;
            '~'|alias)
                if [[ -z $name ]]; then
                    syntax $cmd name command
                else
                    data=${data:-default}
                    case "$name" in
                        s|w|save|write)
                            format_aliases > "$config/aliases/$data"
                            echo "'$data' aliases file updated."
                            ;;
                        l|load)
                            load_aliases "$data"
                            ;;
                        list)
                            for name in "${!aliases[@]}"; do
                                printf '%s: %s\n' "$name" "${aliases["$name"]}"
                            done
                            ;;
                        *)
                            if [[ $data ]]; then
                                aliases["$name"]=$data
                                echo "Alias '$name' created."
                            else
                                unset aliases["$name"]
                                echo "Alias '$name' deleted."
                            fi
                            ;;
                    esac
                fi
                ;;
            f|fmt|format)
                save_undo
                fmt=$((!--fmt + 1))
                ;;
            o|open)
                if [[ -z $LAUNCHER ]]; then
                    echo 'No $LAUNCHER is set.'
                else
                    oifs=$IFS
                    IFS=$'\n'
                    shopt -s nullglob
                    data=("${file%.*}".!("${file##*.}"))
                    shopt -u nullglob
                    IFS=$oifs
                    count=${#data[@]}
                    if [[ $count == 0 ]]; then
                        echo 'No related files found.'
                    elif [[ $count == 1 ]]; then
                        echo "Opened $data with $LAUNCHER."
                        $LAUNCHER "$data"
                    else
                        count=0
                        for f in "${data[@]}"; do
                            echo "$((count++)): $f"
                        done
                        read -e -p'Open which file (none to cancel)? ' f
                        if [[ $f =~ '^[0-9]+$' && ${data["$f"]} ]]; then
                            echo "Opened ${data[$f]} with $LAUNCHER."
                            $LAUNCHER "${data[$f]}"
                        else
                            echo 'Invalid number selected.'
                        fi
                    fi
                fi
                ;;
            w|write|save)
                [[ -z $name || $name == '.' ]] &&
                    name=$file
                if [[ -z $data ]]; then
                    data=$fmt
                elif [[ $data != 1 ]]; then
                    data=2
                fi
                $"format_kvp$data" > "$name"
                fmt=$data
                echo "Wrote KVP$data: $name"
                unset modified
                ;;
            e|revert)
                save_undo
                parse "$file" ||
                    return 1
                echo 'Reverted all changes.'
                unset modified
                ;;
            n|'>'|next|v|'<'|prev)
                if [[ $cmd == @(n|>|next) ]]; then
                    go=1
                else
                    go=-1
                fi
                next=$((index + go))
                if ((next < 0)); then
                    echo 'Already editing first file.'
                    continue
                elif ((next == ${#files[@]})); then
                    echo 'Already editing last file.'
                    continue
                else
                    index=$next
                fi
                ;&
            q|quit|exit)
                if [[ $modified ]]; then
                    echo
                    $"format_kvp$fmt"
                    echo
                    read -e -p'Save changes (Y/n)? ' save
                    clear
                    title
                    if [[ -z $save || ${save,,} == 'y' ]]; then
                        $"format_kvp$fmt" > "$file"
                        echo "Wrote KVP$fmt: $file"
                    fi
                fi
                break
                ;;
            h|help|cmds|commands)
                cmd_usage | less
                ;;
            '')
                ;;
            *)
                echo 'Unknown command.'
                ;;
        esac
    done
    [[ -z $go ]] &&
        unset index
    return 0
}


############
### Main ###
############

if [[ -z $1 || $1 == @('-h'|'--help') ]]; then
    echo "wvm-kvp - Key-Value Pair Editor"
    echo "Version $version by Scott Garrett"
    echo "Wintervenom [(at)] gmail.com"
    echo
    echo "Usage: ${0##*/} <file ...>"
    exit 2
fi

files=("$@")
index=0

mkdir -p "$config/aliases"
clear
title
while [[ $index ]]; do
    key_editor "${files[index]}" ||
        break
done
echo 'Exiting.'
