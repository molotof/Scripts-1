#!/bin/bash
### wvm-kvp: Key-Value Pair Editor ####
# Version 20120220-3 by Scott Garrett #
# Wintervenom [(at)] archlinux.us     #
#######################################
# Optional Dependencies:
# - wvm-open
shopt -s extglob

version=20120920-3
tmp="/tmp/desc-editor.txt"
config="$HOME/.config/wvm-kvp"

declare -A buffer paste aliases
type -p nano > /dev/null &&
    EDITOR=${EDITOR:-nano} ||
    EDITOR=${EDITOR:-vi}
type -p open > /dev/null &&
    LAUNCHER=${LAUNCHER:-open} ||
    LAUNCHER=${LAUNCHER:-wvm-open}


########################
### KVP File Parsing ###
########################
parse () {
    local name data trash
    key=()
    if [[ ! -f "$1" ]]; then
        echo "Not found."
        return 1
    fi
    fmt=$(detect_fmt "$1" 2> /dev/null)
    if [[ -z $fmt ]]; then
        echo "Unknown format."
        return 2
    fi
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        if [[ ${buffer["$name"]} ]]; then
            buffer["$name"]+=$'\n'"$data"
        else
            buffer["$name"]=$data
        fi
    done < <($"parse_kvp$fmt" "$1" 2> /dev/null)
}

detect_fmt () {
    grep -v '#' "$1" | head -3 | awk '
        /^[[:alnum:]_.-]+:/ {
            print "2"
            exit
        }
        /^[[:alnum:]_.-]+$/ {
            print "1"
            exit
        }
    '
}

parse_kvp1 () {
    awk '
        BEGIN {
            name = ""
        }
        /^[[:alnum:]_.-]/ {
            sub(/\s+$/, "", $0)
            name = $0
            next
        }
        {
            if (!name)
                next
            sub(/^\s+/, "", $0)
            sub(/\s+$/, "", $0)
            gsub(/\t/, " ", $0)
            printf "%s\t%s\n", name, $0
        }
    ' "$1"
}

parse_kvp2 () {
    awk -F':' '
        BEGIN {
            name = ""
        }
        {
            if (!name) {
                if ($0 !~ /^[[:alnum:]_.-]+:/)
                    next
                if ($2 ~ /\s*>\s*/) {
                    name = $1
                    next
                }
                printf "%s\t", $1
                sub(/^.*:\s*/, "", $0)
                sub(/\s+$/, "", $0)
                gsub(/\t/, "    ", $0)
            } else if ($2 ~ /<\s*/) {
                name = ""
                next
            } else printf "%s\t", name
            print $0
        }
    ' "$1"
}

format_kvp1 () {
    local name IFS=$'\n'
    set -f
    while read name; do
        [[ -z $name ]] &&
            continue
        echo "$name"
        printf '    %s\n' ${buffer["$name"]}
    done < <(printf '%s\n' "${!buffer[@]}" | sort)
    set +f
}

format_kvp2 () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${buffer["$name"]} != *$'\n'* ]]; then
            echo "$name: ${buffer["$name"]}"
        else
            printf '%s\n' "$name: >" "${buffer["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!buffer[@]}" | sort)
}



##################
### Key Editor ###
##################
title () {
    echo '------------------------------------------'
    echo "wvm-kvp $version - Key-Value Pair Editor"
    echo '------------------------------------------'
}

syntax () {
    IFS=' ' echo "Syntax: ${1#cmd_*} $(printf "<%s> " "${@:2}")"
}

successful () {
    [[ $? == 0 ]]
}

stderr () {
    echo "$1" >&2
    continue
}

save_undo () {
    undo=("$($"format_kvp$fmt")" "${undo[@]:0:49}")
    redo=()
    modified=1
}

load_aliases () {
    local name data trash
    if [[ -z "$config/aliases/$1" ]]; then
        echo "'$1' alias file not found."
        return 1
    fi
    aliases=()
    while IFS=$'\t' read name data trash; do
        [[ -z $name ]] &&
            continue
        name=${name,,}
        aliases["$name"]=$data
    done < <(parse_kvp2 "$config/aliases/$1" 2> /dev/null)
    echo "Loaded aliases from '$1'."
}

format_aliases () {
    local name
    for name in "${!aliases[@]}"; do
        echo "$name: ${aliases["$name"]}"
    done
}

format_paste () {
    local name IFS=$'\n'
    while read name; do
        [[ -z $name ]] &&
            continue
        if [[ ${paste["$name"]} != *$'\n'* ]]; then
            echo "$name: ${paste["$name"]}"
        else
            printf '%s\n' "$name: >" "${paste["$name"]}" '<'
        fi
    done < <(printf '%s\n' "${!paste[@]}" | sort)
}

deblank () {
    sed '/./,$!d' "$1" | sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'
}

validate () {
    [[ $1 =~ ^[[:alnum:]._-]+$ ]] &&
        return 0
    echo 'Key not found or invalid key name.'
    return 1
}

key () {
    local name
    unset found value
    [[ $2 ]] &&
        save_undo
    for name in "${!buffer[@]}"; do
        if [[ $name =~ ^$1$ ]]; then
            if [[ -z $2 ]]; then
                found=$name
                break
            else
                ((found++))
                if [[ $2 != ':u' ]]; then
                    if [[ $3 && ${buffer["$name"]} ]]; then
                        buffer["$name"]+="$3$2"
                    else
                        buffer["$name"]=$2
                    fi
                else
                    unset buffer["$name"]
                fi
            fi
        fi
    done
    if [[ $found ]]; then
        [[ -z $2 ]] &&
            value=${buffer["$name"]}
        return 0
    elif [[ $2 ]]; then
        validate "$1" ||
            continue
        found='new'
        if [[ $2 != ':u' ]]; then
            buffer["$1"]=$2
        else
            unset buffer["$1"]
        fi
    else
        echo "No key matching '$1'."
        continue
    fi
}

paste_key () {
    local name
    unset found value
    for name in "${!paste[@]}"; do
        if [[ $name =~ ^$1$ ]]; then
            if [[ -z $2 ]]; then
                found=$name
                break
            else
                ((found++))
                if [[ $2 != ':u' ]]; then
                    if [[ $3 && ${paste["$name"]} ]]; then
                        paste["$name"]+="$3$2"
                    else
                        paste["$name"]=$2
                    fi
                else
                    unset paste["$name"]
                fi
            fi
        fi
    done
    if [[ $found ]]; then
        [[ -z $2 ]] &&
            value=${paste["$name"]}
        return 0
    elif [[ $2 ]]; then
        validate "$1" ||
            continue
        found='new'
        if [[ $2 != ':u' ]]; then
            paste["$1"]=$2
        else
            unset paste["$1"]
        fi
    else
        echo "No key matching '$1'."
        continue
    fi
}

paginate () {
    # TODO
    true
}


### Editor Commands ###
cmd_set () {
    case "$1" in
        '-i')
            params=('key' '?text')
            names=('=' 's')
            ;;
        '-h')
            cat <<'EOF'
Sets the value of keys matching <key> to <text>. If <text> is left blank, then
$EDITOR will be launched for you to edit the key's value. If <text> is set to
a period, the name of the file being edited (without the extension) will be
substituted.
EOF
            ;;
        *)
            if [[ $2 ]]; then
                text=$2
            else
                if [[ $3 ]]; then
                    echo > "$tmp"
                else
                    key "$1" > "$tmp"
                fi
                $EDITOR "$tmp"
                text=$(deblank "$tmp")
                if ! successful; then
                    stderr 'Empty value. No changes made.'
                    return 1
                fi
                rm -f "$tmp"
            fi
            if [[ -z $text ]]; then
                stdout 'Empty value.  No changes made.'
                return 1
            elif [[ $text == '.' ]]; then
                text=${file##*/}
                text=${text%.*}
            fi
            key "$1" "$text" "$3"
            echo "Updated value of $found key(s) matching '$name'."
            ;;
    esac
}

cmd_add () {
    case "$1" in
        '-i')
            params=('key' '?text')
            names=('+' 'a')
            ;;
        '-h')
            cat <<'EOF'
Same as the `set` command, but appends <text> to the value of <key>, prefixed
with a space, if the key is not empty.
EOF
            ;;
        *)
            set "$1" "$2" ' '
            ;;
    esac
}

cmd_addln () {
    case "$1" in
        '-i')
            params=('key' '?value')
            names=(';' 'l')
            ;;
        '-h')
            cat <<'EOF'
Same as the `set` command, but appends <text> to the value of <key>, prefixed
with a newline, if the key is not empty.
EOF
            ;;
        *)
            cmd_set "$1" "$2" $'\n'
            ;;
    esac
}

cmd_unset () {
    case "$1" in
        '-i')
            params=('key' '?buffer')
            names=('-' 'rm')
            ;;
        '-h')
            cat <<'EOF'
Deletes keys matching <key>. If <buffer> is set to 'paste'/'p', the matching
keys will be deleted from the paste buffer instead of the main one. If it is
set to 'all'/'a', will delete matching keys from both buffers.
EOF
            ;;
        *)
            if [[ $2 == @(p|paste) ]]; then
                paste_key "$1" :u
                echo "Deleted $found paste key(s) matching '$1'."
            fi
            if [[ -z $2 || $2 == @(a|all) ]]; then
                key "$1" :u
                echo "Deleted $found key(s) matching '$1'."
            fi
            ;;
    esac
}

cmd_clear () {
    case "$1" in
        '-i')
            params=('[a]ll|[b]uffer|[p]aste')
            names=('x')
            ;;
        '-h')
            cat <<'EOF'
Clears all keys from either the main buffer, pastes, or both.
EOF
            ;;
        *)
            case "$1" in
                a|all)
                    paste=()
                    echo 'Cleared pastes'
                    ;&
                b|buffer)
                    save_undo
                    buffer=()
                    echo 'Cleared buffer.'
                    ;;
                p|paste)
                    paste=()
                    echo 'Cleared pastes'
                    ;;
                *)
                    echo 'Unknown buffer.'
                    return 1
                    ;;
            esac
            ;;
    esac
}

cmd_copy () {
    case "$1" in
        '-i')
            params=('key' '?to')
            names=('c')
            ;;
        '-h')
            cat <<'EOF'
Copies key matching <key> to the paste buffer, optionally to different key(s)
(<to>). If <key> is empty, will copy all keys.
EOF
            ;;
        *)
            if [[ $1 ]]; then
                target=${2:-$1}
                key "$1"
                name=$found
                paste_key "$target" "$value"
                echo "Copied key '$name' as $found paste(s) matching '$target'."
            else
                for name in "${!buffer[@]}"; do
                    paste["$name"]=${buffer["$name"]}
                done
                echo 'Copied all keys.'
            fi
            ;;
    esac
}

cmd_paste () {
    case "$1" in
        '-i')
            params=('key' '?to')
            names=('p')
            ;;
        '-h')
            cat <<'EOF'
Pastes key matching <key> from the paste buffer, optionally to different key(s)
(<to>). If <key> is empty, will paste all keys.
EOF
            ;;
        *)
            if [[ $1 ]]; then
                target=${2:-$1}
                paste_key "$1"
                name=$found
                key "$target" "$value"
                echo "Pasted '$name' to $found key(s) matching '$target'."
            else
                for name in "${!paste[@]}"; do
                    buffer["$name"]=${paste["$name"]}
                done
                echo 'Pasted all keys.'
            fi
            ;;
    esac
}

cmd_undo () {
    case "$1" in
        '-i')
            params=()
            names=('z')
            ;;
        '-h')
            cat <<'EOF'
Restores main buffer to state before the last edit. Up to 50 changes are saved.
EOF
            ;;
        *)
            if [[ $undo ]]; then
                redo=("$($"format_kvp$fmt")" "${redo[@]}")
                printf '%s\n' "$undo" > "$tmp"
                undo=("${undo[@]:1}")
                parse "$tmp"
                rm -f "$tmp" 2> /dev/null
                modified=1
                echo 'Reverted last change.'
            else
                echo 'Already at oldest change.'
            fi
            ;;
    esac
}

cmd_redo () {
    case "$1" in
        '-i')
            params=()
            names=('y')
            ;;
        '-h')
            cat <<'EOF'
Restores main buffer to state before the last undo (if it hasn't been changed
since then).
EOF
            ;;
        *)
            if [[ $redo ]]; then
                undo=("$($"format_kvp$fmt")" "${undo[@]}")
                printf '%s\n' "$redo" > "$tmp"
                redo=("${redo[@]:1}")
                parse "$tmp"
                rm -f "$tmp" 2> /dev/null
                modified=1
                echo 'Restored last change.'
            else
                echo 'Already at latest change.'
            fi
            ;;
    esac
}

cmd_rename () {
    case "$1" in
        '-i')
            params=('key' 'name')
            names=('r' 'mv')
            ;;
        '-h')
            cat <<'EOF'
Renames key matching <key> to <name>.
EOF
            ;;
        *)
            validate "$2" ||
                continue
            key "$1"
            name=$found
            unset buffer["$name"]
            key "$2" "$value"
            echo "Renamed key '$name' to '$2'."
            ;;
    esac
}

cmd_lowercase () {
    case "$1" in
        '-i')
            params=('key')
            names=('l' 'lower')
            ;;
        '-h')
            cat <<'EOF'
Lowercases the value of key matching <key>.
EOF
            ;;
        *)
            key "$1"
            name=$found
            key "$name" "${value,,}"
            echo "Lowercased value of key '$name'."
            ;;
    esac
}

cmd_uppercase () {
    case "$1" in
        '-i')
            params=('key')
            names=('u' 'upper')
            ;;
        '-h')
            cat <<'EOF'
Uppercases the value of key matching <key>.
EOF
            ;;
        *)
            key "$1"
            name=$found
            key "$name" "${value^^}"
            echo "Uppercased value of key '$name'."
            ;;
    esac
}

cmd_sed () {
    case "$1" in
        '-i')
            params=('key' 'script')
            names=('%')
            ;;
        '-h')
            cat <<'EOF'
Sets the value of key matching <key> to the result of a Sed operation using
<script>. Sed will be executed with extended regular expressions enabled.
EOF
            ;;
        *)
            key "$1"
            name=$found
            value=$(printf '%s\n' "$value" | sed -r "$2")
            if [[ $? == 0 ]]; then
                key "$name" "$value"
                echo "Updated value of key '$name'."
            fi
            ;;
    esac
}

cmd_alias () {
    case "$1" in
        '-i')
            params=('name' 'command|ls|[l]oad|[s]ave')
            names=()
            ;;
        '-h')
            cat <<'EOF'
EOF
            ;;
        *)
            target=${2:-default}
            case "$1" in
                s|w|save|write)
                    format_aliases > "$config/aliases/$target"
                    echo "'$target' aliases file updated."
                    ;;
                l|load)
                    load_aliases "$target"
                    ;;
                ls|list)
                    for name in "${!aliases[@]}"; do
                        printf '%s: %s\n' "$name" "${aliases["$name"]}"
                    done
                    ;;
                *)
                    if [[ $2 ]]; then
                        aliases["$1"]=$2
                        echo "Alias '$1' created."
                    else
                        unset aliases["$1"]
                        echo "Alias '$1' deleted."
                    fi
                    ;;
            esac
            ;;
    esac
}

cmd_format () {
    case "$1" in
        '-i')
            params=()
            names=('f' 'fmt')
            ;;
        '-h')
            cat <<'EOF'
Toggles the buffer format between KVP1 and KVP2.
EOF
            ;;
        *)
            fmt=$((!--fmt + 1))
            ;;
    esac
}

cmd_open () {
    case "$1" in
        '-i')
            params=()
            names=('o' 'launch')
            ;;
        '-h')
            cat <<'EOF'
Opens the related file that is detected by the editor with the executable in
$LAUNCHER. If more than one related file is found, will prompt you to choose
which one to open.
EOF
            ;;
        *)
            if [[ -z $LAUNCHER ]]; then
                echo 'No $LAUNCHER is set.'
            else
                oifs=$IFS
                IFS=$'\n'
                shopt -s nullglob
                data=("${file%.*}".!("${file##*.}"))
                shopt -u nullglob
                IFS=$oifs
                count=${#data[@]}
                if [[ $count == 0 ]]; then
                    echo 'No related files found.'
                elif [[ $count == 1 ]]; then
                    echo "Opened $data with $LAUNCHER."
                    $LAUNCHER "$data"
                else
                    count=0
                    for f in "${data[@]}"; do
                        echo "$((count++)): $f"
                    done
                    read -e -p'Open which file (none to cancel)? ' f
                    if [[ $f =~ '^[0-9]+$' && ${data["$f"]} ]]; then
                        echo "Opened ${data[$f]} with $LAUNCHER."
                        $LAUNCHER "${data[$f]}"
                    else
                        echo 'Invalid number selected.'
                    fi
                fi
            fi
            ;;
    esac
}

cmd_write () {
    case "$1" in
        '-i')
            params=('?filepath' 'version')
            names=('w' 'save')
            ;;
        '-h')
            cat <<'EOF'
Writes main buffer to file, optionally to a different <filepath> than what was
opened. '.' used as a filepath will write to the original file (default).
Output is written in whichever KVP version it was opened in unless <version>
is specified after the file path ('1' or '2').
EOF
            ;;
        *)
            [[ -z $1 || $1 == '.' ]] &&
                name=$file
            $"format_kvp$fmt" > "$name"
            fmt=$data
            echo "Wrote KVP$data: $name"
            unset modified
            ;;
    esac
}

cmd_revert () {
    case "$1" in
        '-i')
            params=()
            names=('e')
            ;;
        '-h')
            cat <<'EOF'
Revert main buffer to the last-saved state.
EOF

            ;;
        *)
            save_undo
            parse "$file" ||
                return 1
            echo 'Reverted all changes.'
            unset modified
            ;;
    esac
}

cmd_go () {
    # Make aliases: prev, next = go -1, go +1
    case "$1" in
        '-i')
            params=('index')
            names=('g')
            ;;
        '-h')
            cat <<'EOF'
EOF
            ;;
        *)

            if [[ ${1:0:1} == @('+'|'-') ]]; then
                next=$((index $1))
            else
                next=$1
            fi
            if [[ $next -lt 0 || $next -gt ${#files[@]} ]]; then
                stderr 'Invalid index.'
                return 1
            else
                index=$next
            fi
            ;;
    esac
}

cmd_quit () {
    case "$1" in
        '-i')
            params=()
            names=('q')
            ;;
        '-h')
            cat <<'EOF'
Exits the editor.
EOF
            ;;
        *)
            if [[ $modified ]]; then
                echo
                $"format_kvp$fmt"
                echo
                read -e -p'Save changes (Y/n)? ' save
                clear
                title
                if [[ -z $save || ${save,,} == 'y' ]]; then
                    $"format_kvp$fmt" > "$file"
                    echo "Wrote KVP$fmt: $file"
                fi
            fi
            break
            ;;
    esac
}

cmd_help () {
    case "$1" in
        '-i')
            params=('?command')
            names=('h' 'help' 'cmds' 'commands')
            ;;
        '-h')
            cat <<'EOF'
You are currently here.  Press [q] to return to the editor.
EOF
            ;;
        *)
            cmd_usage | less
            ;;
    esac
}

_cmd_template () {
    case "$1" in
        '-i')
            params=()
            names=()
            ;;
        '-h')
            cat <<'EOF'
EOF
            ;;
        *)
            ;;
    esac
}

key_editor () {
    local file=$1 cmd name data modified append undo=() redo=()
    if [[ ${file##*.} != @(txt|text|desc|meta|kvp|rc|conf|cfg) ]]; then
        echo "Related: $file"
        file="${file%.*}.txt"
    fi
    echo "Parsing: $file"
    if ! parse "$file"; then
        echo 'Using blank KVP2.'
        fmt=2
    fi
    while :; do
        printf '\n[KVP%s: %s]\n' "$fmt" "${file##*/}"
        $"format_kvp$fmt"
        printf '\n\n[Paste Buffer]\n'
        format_paste
        printf '\n\n'
        read -e -p'> ' cmd name data
        clear
        title
        unset append go
        cmd=${cmd,,}
        name=${name,,}
        [[ $cmd && ${aliases["$cmd"]} ]] &&
            read cmd name data <<< "${aliases["$cmd"]}"
        case "$cmd" in
            h|help|cmds|commands)
                ;;
            '')
                ;;
            *)
                echo 'Unknown command.'
                ;;
        esac
    done
    [[ -z $go ]] &&
        unset index
    return 0
}


############
### Main ###
############

if [[ -z $1 || $1 == @('-h'|'--help') ]]; then
    echo "wvm-kvp - Key-Value Pair Editor"
    echo "Version $version by Scott Garrett"
    echo "Wintervenom [(at)] gmail.com"
    echo
    echo "Usage: ${0##*/} <file ...>"
    exit 2
fi

files=("$@")
index=0

mkdir -p "$config/aliases"
clear
title
while [[ $index ]]; do
    key_editor "${files[index]}" ||
        break
done
echo 'Exiting.'
